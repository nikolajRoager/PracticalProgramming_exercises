<!DOCTYPE html>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="quadratures_files/style.css">
</head>
<body data-new-gr-c-s-check-loaded="8.896.0" data-gr-ext-installed="">
<font size="-1">
<a href="http://80.251.205.75/~fedorov/prog/">←to practical programming</a>
</font>

<h3>Homework "Adaptive Integration"</h3>

<ol type="A">
<li><p>(6 points) <b>Recursive adaptive integrator</b>

</p><p> Implement a recursive open-quadrature adaptive integrator that
estimates the integral of a given function <i>f(x)</i> on a given interval
<i>[a,b]</i> with the required absolute, <i>δ</i>, or relative,
<i>ε</i>, accuracy goals.

</p><p>The integrator has to use a combination of a higher order
quadrature and an imbedded lower order quadrature (to estimate the
local error).

</p><p>Something like
</p><pre>static double integrate
(Func&lt;double,double&gt; f, double a, double b,
double δ=0.001, double ε=0.001, double f2=NaN, double f3=NaN)
{
double h=b-a;
if(IsNaN(f2)){ f2=f(a+2*h/6); f3=f(a+4*h/6); } // first call, no points to reuse
double f1=f(a+h/6), f4=f(a+5*h/6);
double Q = (2*f1+f2+f3+2*f4)/6*(b-a); // higher order rule
double q = (  f1+f2+f3+  f4)/4*(b-a); // lower order rule
double err = |Q-q|;
if (err ≤ δ+ε|Q|) return Q;
else return integrate(f,a,(a+b)/2,δ/√2,ε,f1,f2)+
            integrate(f,(a+b)/2,b,δ/√2,ε,f3,f4);
}
</pre>

<p>Remember to reuse points!

</p><p> Test your implementation on some interesting integrals, for example
(check the expressions before using),

</p><pre><b><i>∫</i></b><sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx √(x) = 2/3 ,
<b><i>∫</i></b><sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx 1/√(x) = 2 ,
∫<sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx 4√(1-x²) = π ,
∫<sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx ln(x)/√(x) = -4
</pre>

<p>Using your integrator implement the error function via its integral
representation,
</p><pre>erf(z) = <b>∫</b><sub><sub>0</sub></sub><sup><sup>z</sup></sup> dx 2/√π exp(-x²) ,
</pre>
make a plot, compare with exact results.

</li><li><p>(3 points)
<b>Open quadrature with Clenshaw–Curtis variable transformation</b>

</p><p>Inplement an (open quandrature) adaptive integrator
with the Clenshaw–Curtis variable transformation,

</p><pre>∫<sub><sub>-1</sub></sub><sup><sup>1</sup></sup> f(x)dx = ∫<sub><sub>0</sub></sub><sup><sup>π</sup></sup> f(cos(θ))sinθdθ  
</pre>
<pre>∫<sub><sub>a</sub></sub><sup><sup>b</sup></sup>dx f(x) = ∫<sub><sub>0</sub></sub><sup><sup>π</sup></sup>dθ f( (a+b)/2+(b-a)/2*Cos(θ) )*Sin(θ)*(b-a)/2
</pre>

<p>
Calculate some integrals with integrable divergencies
at the end-points of the intervals;
record the number of integrand evaluations;
compare with your ordinary integrator without variable transformation. For
example,

</p><pre><b><i>∫</i></b><sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx 1/√(x) = 2 ,
<b><i>∫</i></b><sub><sub>0</sub></sub><sup><sup>1</sup></sup> dx ln(x)/√(x) = -4 .
</pre>

<p>Compare the number of integrand evaluations with the python/numpy's
integration routines.

</p></li><li><p>(1 point)
<b>Infinite limits</b>

</p><p>Make your integrator estimate and return the integration error.

</p><p>Generalize your integrator to accept infinite limits.
An infinite limit integral can be converted by a variable transformation
(see lecture notes) into a finite limit integral, which can then be
evaluated by your integrator.

</p><p>Hints:
<tt>double.PositiveInfinity</tt>,
<tt>IsInfinity</tt>,
<tt>IsNegativeInfinity</tt>,
<tt>IsPositiveInfinity</tt>.

</p><p>Test your implementation on some (converging) infitine limit integrals
and note the number of integrand evaluations.

</p><p>Compare with the python/numpy integration routines.

<!--
<b>Compare your integrator with your ODE driver.</b>
<p> A definite integral,
<pre>
<i>Q=&int;<sub><sub>a</sub></sub><sup><sup>b</sup></sup>f(x)dx ,
</i></pre>
can be
reformulated as an initial-value ordinary differential equation problem,
<pre>
<i>y'=f(x), y(a)=0, Q=y(b)</i>,
</pre>
which can be solved with your adaptive ODE
solver.
<p>Pick an interesing <i>f(x)</i> and compare the effectiveness of
your ODE drivers with your adaptive integrators.
-->

</p></li>

<!--
<li>(0 points)

<li><p>(0 point) Singular integrands

	<ul>

<li>Devise a quadrature which can integrate exactly
<i>1/&radic;x</i> and/or <i>log(x)</i> etc.

<li>Implement an adaptive integrator which generally uses closed
quadrature but switches to this quadrature in the vicinity of a detected
singularity.

<li>Calculate
<code>
<b><i>&int;</i></b><sub><sub>0</sub></sub><sup><sup>1</sup></sup>
&nbsp;dx&nbsp;(<sup>ln(x)</sup><i>/</i><sub>&radic;(x)</sub>) = -4
</code>
with <code>acc=eps=0.001</code> and estimate the number of integrand
evaluations with you open-adaptive integrator from exercise A and the
present integrator.

<li>Compare with library routines (for example, gsl_integration_qags).

	</ul>
-->

</ol>


</body><grammarly-desktop-integration data-grammarly-shadow-root="true"></grammarly-desktop-integration></html>